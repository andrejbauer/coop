(* Simulate writing to a file where the disk becomes full. *)

(* A file is a list of integers. *)
type file = Nil | Cons of int * file

(* The size of a file *)
let rec length (f : file) : int =
  match f with {
  | Nil -> 0
  | Cons (_, f) -> 1 + length f
  }

operation write : int -> unit

signal disk_full of unit

(** A runner that implements a file writer that is full after n writes. *)
let file_writer (n : int) =
  {
  | write k ->
     let w = getenv in 
     if (user length w >= n with {}) then
       !!disk_full ()
     else
       (setenv (Cons (k, w));
       ())
  } @ file

let job (_ : unit) =
    write 1 ;
    write 2 ;
    write 3 ;
    write 4 ;
    write 5 ;
    write 6

(* Write 6 times to a file, don't trigger a signal. *)
let demo1 =
  using file_writer 10 @ Nil
  run
    job ()
  finally {
  | return _ @ f -> f
  | !!disk_full _ -> Nil
  }

(* Write 6 times to a file, trigger a signal. *)
let demo2 =
  using file_writer 3 @ Nil
  run
    job ()
  finally {
  | return _ @ f -> f
  | !!disk_full _ -> Nil
  }