(** Standard state. *)

(** The operations for accessing and modifyng state *)
operation get : unit -> int
operation put : int -> unit

(** Another set of operations, used when we combined several states *)
operation get' : unit -> int
operation put' : int -> unit

(** A signal used for the cohandler that only allows positive integers *)
signal negative of int

(** Basic state *)
let state =
  cohandler int with
  | get () @ w -> (w, w)
  | put w' @ _ -> ((), w')
  end

(** A copy of state with renamed operations *)
let state' = state with {get as get', put as put'}

(** State that only allows non-negative integers to be stored *)
let positive_state =
  cohandler int with
  | get _ @ w -> (w, w)
  | put w @ _ -> if w < 0 then negative w else ((), w)
  end

(** This is how we use ordinary state, initialized with 1 *)
let demo1 =
  use state @ 1 in
    let a = get () in
    put 2 ;
    let b = get () in
    put 3 ;
    (a, b)
  finally
    val x @ _ -> x
  end

let state2 = state ⊗ state'

(** Combine two states together, each has its own state *)
let demo2 =
  use state ⊗ state' @ (2, 3)in
    let a = get' () in
    put 3 ;
    put' (a + 10) ;
    let b = get' () in
    (a, b)
  finally
  | val x @ w -> (x, w)
  end

(* Combine two copies of state, one of which only allows positive values. *)
let demo3 =
  use state' ⊗ positive_state @ (0, 2) in
    let a = get' () in
    put 3 ;
    put' (a + 10) ;
    let b = get' () in
    (a, b)
  finally
  | val x @ w -> (x, w)
  | negative k @ w -> ((0, k), w)
  end

(* Combine two copies of state, one of which only allows positive values,
   trigger a signal. *)
let demo3' =
  use state' ⊗ positive_state @ (0, 2) in
    let a = get' () in
    put 3 ;
    put' (a + 10) ;
    let b = get' () in
    put (-1) ;
    (a, b)
  finally
  | val x @ w -> (x, w)
  | negative k @ w -> ((666, k), w)
  end
