(** Standard state. *)

(** The operations for accessing and modifyng state *)
operation get : unit -> int
operation put : int -> unit

(** Another set of operations, used when we combined several states *)
operation get' : unit -> int
operation put' : int -> unit

(** A signal used for the comodel that only allows positive integers *)
signal negative of int

(** Basic state *)
let state (w0 : int) =
  comodel w0 with
  | get () @ w -> (w, w)
  | put w' @ _ -> ((), w')
  end

(** A copy of state with renamed operations *)
let state' (w0 : int) = state w0 with {get as get', put as put'}

(** State that only allows non-negative integers to be stored *)
let positive_state (w0 : int) =
  comodel w0 with
  | get _ @ w -> (w, w)
  | put w @ _ -> if w < 0 then negative w else ((), w)
  end

(** This is how we use ordinary state, initialized with 1 *)
let demo1 =
  using state 1 in
    let a = get () in
    put 2 ;
    let b = get () in
    put 3 ;
    (a, b)
  finally
    val x @ _ -> x
  end

let state2 (u : int) (v : int) = state u ⊗ state' v

(** Combine two states together, each has its own state *)
let demo2 =
  using state 2 ⊗ state' 3 in
    let a = get' () in
    put 3 ;
    put' (a + 10) ;
    let b = get' () in
    (a, b)
  finally
  | val x @ w -> (x, w)
  end

(* Combine two copies of state, one of which only allows positive values. *)
let demo3 =
  using state' 0 ⊗ positive_state 2 in
    let a = get' () in
    put 3 ;
    put' (a + 10) ;
    let b = get' () in
    (a, b)
  finally
  | val x @ w -> (x, w)
  | negative k @ w -> ((0, k), w)
  end

(* Combine two copies of state, one of which only allows positive values,
   trigger a signal. *)
let demo3' =
  using state' 0 ⊗ positive_state 2 in
    let a = get' () in
    put 3 ;
    put' (a + 10) ;
    let b = get' () in
    put (-1) ;
    (a, b)
  finally
  | val x @ w -> (x, w)
  | negative k @ w -> ((666, k), w)
  end
